// Copyright (c) 2003-2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


//
// This module converts a parse-tree into an ITree. More specifically it takes a parse tree
// representing a module into an ITree::IModule instance. This conversion is largely mechanical and
// (intentionally) doesn't do very much clever (apart from evaluating splices). The cleverness
// happens in Code_Gen.cv and QQ_Mode.cv.
//


import Builtins, CPK::Tree, Exceptions, Strings, Sys, VM
import Code_Gen, Core, BC_Mod, ITree, ITree_Rename, ITree_WF, Lift




SRC_INFO_VAR := "__SRC_INFO__"

_NEST_FUNC := 0
_NEST_CLASS := 1




class IMod_Gen:

    func init(self):

        self._defns := []
        self._nesting := []
        self._meta_level := 0

        // These next two slots are purely for convenience.

        self._compiler := Core::peek_compiler()
        self._mod_id := self._compiler.mod_id



    func gen(self, parse_tree):

        itree := self._preorder(parse_tree)
        ITree_WF::wf(itree)

        return itree



    func gen_expr_seq(self, parse_tree):

        itree := self._preorder(parse_tree)
        ITree_WF::wf(itree)

        return itree



    /////////////////////////////////////////////////////////////////////////////////////////////////
    // Helper functions
    //

    func _eval_splice(self, node, extra_src_infos):

        // splice ::= expr_splice
        //          | dsl_splice
        //          | if_splice
        
        // This function is unique since it's the "coal face" for compile-time meta-programming.
        //
        // This is a euphemism for "it's a bit complicated".
        
        if node[0].name == "expr_splice" | node[0].name == "dsl_splice":
            st_node := node[0][1]
            if st_node.len() == 1:
                // splice_type ::= "ID"
                type_str := st_node[0].value
                if type_str == "c":
                    st := ITree::SPLICE_CAPTURING
                elif type_str == "p":
                    st := ITree::SPLICE_PRAGMA
                else:
                    msg := Strings::format("Unknown splice type '%s'.", type_str)
                    self._compiler.error(msg, node.src_infos)
            else:
                st := ITree::SPLICE_DEFAULT

            if node[0].name == "expr_splice":
                // expr_splice  ::= "$" splice_type "<" expr ">"
                meta_level_o := self._meta_level
                self._meta_level := 0
                expr := self._preorder(node[0][3], extra_src_infos)
                self._meta_level := meta_level_o
            else:
                // dsl_splice ::= "$" splice_type "<<" expr ">>" ":" "DSL_BLOCK"
                //            ::= "$" splice_type "<<" expr ">>" "<<" "DSL_BLOCK" ">>"
                dsl_node := node[0]
                dsl_block := ITree::IString.new(dsl_node[6].value, extra_src_infos + dsl_node.src_infos)

                assert dsl_node.src_infos.len() == 1
                src_path := ITree::IString.new(dsl_node[6].src_infos[0][0], extra_src_infos + node[0][0].src_infos)
                src_offset := ITree::IInt.new(dsl_node[6].src_infos[0][1], extra_src_infos + node[0][0].src_infos)
                src_len := ITree::IInt.new(dsl_node[6].src_infos[0][2], extra_src_infos + dsl_node.src_infos)
                src_infos := ITree::IList.new([ITree::IList.new([src_path, src_offset, src_len], extra_src_infos + node[0][0].src_infos)], extra_src_infos + dsl_node.src_infos)

                meta_level_o := self._meta_level
                self._meta_level := 0
                expr := ITree::IApplication.new(self._preorder(dsl_node[3], extra_src_infos), [dsl_block, src_infos], extra_src_infos + node.src_infos)
                self._meta_level := meta_level_o

            if out_itree := self._eval_splice_expr(expr, extra_src_infos + node.src_infos):
                got_val := 1
            else:
                got_val := 0

            if st == ITree::SPLICE_PRAGMA:
                // Pragmas are nice and easy to deal with as we ignore the splices return value and
                // return a simple "pass" statement.
                return ITree::IPass.new(node.src_infos)
        else:
            // splice    ::= if_splice
            // if_splice ::= "$" "IF" "<<" expr ">>" splice_type "<<" expr ">>"
            meta_level_o := self._meta_level
            self._meta_level := 0
            expr := self._preorder(node[0][3], extra_src_infos)
            self._meta_level := meta_level_o
            if not self._eval_splice_expr(expr, extra_src_infos + node.src_infos):
                return ITree::IPass.new(node.src_infos)
            
            if node[0][5].len() == 1:
                // splice_type ::= "ID"
                type_str := node[0][5][0].value
                if type_str == "c":
                    st := ITree::SPLICE_CAPTURING
                elif type_str == "p":
                    st := ITree::SPLICE_PRAGMA
                else:
                    msg := Strings::format("Unknown splice type '%s'.", type_str)
                    self._compiler.error(msg, node.src_infos)
            else:
                st := ITree::SPLICE_DEFAULT
            
            meta_level_o := self._meta_level
            self._meta_level := 0
            expr := self._preorder(node[0][7], extra_src_infos)
            self._meta_level := meta_level_o

            if out_itree := self._eval_splice_expr(expr, extra_src_infos + node.src_infos):
                got_val := 1
            else:
                got_val := 0

        if got_val == 0:
            self._compiler.error("Splice did not return a value.", node.src_infos)
        if out_itree is null:
            self._compiler.error("Splice returned null.", node.src_infos)

        if node[0].name == "expr_splice" | node[0].name == "if_splice":
            // With normal splices, we augment the src infos with the position of the
            // splice (as well as the src infos that the returned itree has as standard).

            if Builtins::List.instantiated(out_itree):
                tmp := []
                for itree := out_itree.iter():
                    if not ITree::IRoot.instantiated(itree):
                        msg := Strings::format( \
                          "Splice returned list including '%s' instead of 'IRoot'", \
                          out_itree.instance_of.name)
                        Core::peek_compiler().error(msg, node.src_infos)
                    tmp.append(itree.extended_src_infos(node.src_infos))
                out_itree := tmp
            else:
                if not ITree::IRoot.instantiated(out_itree):
                    msg := Strings::format( \
                      "Splice returned '%s' instead of '[IRoot, List(IRoot)]'", \
                      out_itree.instance_of.name)
                    Core::peek_compiler().error(msg, node.src_infos)
                out_itree := out_itree.extended_src_infos(node.src_infos)

        if st == ITree::SPLICE_DEFAULT:
            out_itree := ITree_Rename::rename_fresh(out_itree)

        return out_itree



    func _eval_splice_expr(self, expr, src_infos):

        splice_name := Core::fresh_name()
        splice_var := ITree::IVar.new(splice_name, src_infos)

        // Determine all the definitions we've currently processed into ITree's.

        already_bound_vars := Dict{}
        for i := 0.iter_to(self._defns.len()):
            defn := self._defns[i]
            for target_var := defn.bound_vars.iter():
                already_bound_vars[target_var] := i

        defns_to_include := Set{}
        for free_var := expr.free_vars.iter():
            if defn_i := already_bound_vars.find(free_var):
                defns_to_include.add(defn_i)
        if lookups := expr.mod_id_lookups.find(self._mod_id):
            for lookup := lookups.iter():
                if defn_i := already_bound_vars.find(lookup):
                    defns_to_include.add(defn_i)

        stack := Builtins::List.new(defns_to_include)
        i := 0
        while i < stack.len():
            defn := self._defns[stack[i]]
            
            rlv_vars := defn.free_vars.scopy()
            if lookups := defn.mod_id_lookups.find(self._mod_id):
                rlv_vars.extend(lookups)
            
            for free_var := rlv_vars.iter():
                if not defns_to_include.find(free_var) & defn_i := already_bound_vars.find(free_var) & not stack.find_index(defn_i) <= i:
                    stack.append(defn_i)
                    defns_to_include.add(defn_i)

            i += 1

        // Only include the definitions so far processed if they're absolutely necessary (i.e.
        // they're referenced by the splice expression, or referenced by something referenced
        // by the splice expression).

        defns := []
        i := 0
        for i := 0.iter_to(self._defns.len()):
            if defns_to_include.find(i):
                defns.append(self._defns[i])

        tmp_func := ITree::IFunc_Defn.new(0, splice_var, [], null, [], [], ITree::IExpr_Seq.new([ITree::IReturn.new(expr, src_infos)], expr.src_infos), src_infos)
        tmp_defns := defns + [ITree::IAssignment.new(ITree::STD_ASSIGN, [ITree::IVar.new(splice_name, src_infos)], tmp_func, src_infos)]
        tmp_imodule := ITree::IModule.new(splice_name, tmp_defns, src_infos)

        ITree_WF::wf(tmp_imodule)

        tmp_bc_mod := Code_Gen::Code_Gen.new().generate(self._compiler.internal_target, tmp_imodule)

        bc_mod_stack := [tmp_bc_mod]
        mods_to_add := [Builtins::Module.new(tmp_bc_mod.serialize())]
        i := 0
        known_mod_ids := Set{}
        if VM.find_slot("has_defn"): // XXX gross hack
            for known_mod_ids.add(VM::iter_mods().mod_id)
        else:
            for known_mod_ids.add(VM::vm.modules.iter_keys())
        for known_mod_ids.add(Core::BUILTIN_MODULES.iter())
        while bc_mod_stack.len() > 0:
            bc_mod := bc_mod_stack.pop()
            for imp_mod_id, imp_src_path := bc_mod.get_imports().iter():
                if not known_mod_ids.find(imp_mod_id):
                    imp_bc_mod := self._compiler.get_bc_mod(imp_mod_id, imp_src_path, src_infos)
                    mods_to_add.append(Builtins::Module.new(imp_bc_mod.serialize()))
                    bc_mod_stack.append(imp_bc_mod)
                    known_mod_ids.add(imp_mod_id)
            i += 1

        // Import all the modules into the VM.

        VM::add_modules(mods_to_add)
        module := VM::import_module(mods_to_add[0])
        
        if not out_itree := module.get_defn(splice_name)():
            got_val := 0
        else:
            got_val := 1

        // Once we've evaluated the splice we need to remove the temporary module from the list of
        // modules fully imported into the VM (though note that it may not be garbage collected, as
        // references to it may remain). Without this, later splices can pick up a half-formed
        // version of the "real" module which (seemingly inexplicably) will appear to be missing
        // some of its definitions.

        if VM.find_slot("has_defn"): // XXX gross hack
            VM::del_mod(self._mod_id)
        else:
            VM::vm.modules.del(self._mod_id)
        
        if got_val == 1:
            return out_itree
        else:
            fail



    /////////////////////////////////////////////////////////////////////////////////////////////////
    // Node traversal
    //

    func _preorder(self, node, extra_src_infos := []):

        return self.find_slot("_t_" + node.name)(node, extra_src_infos)



    func _t_top_level(self, node, extra_src_infos):

        // top_level ::= defn ( "NEWLINE" defn )*
        //           ::=

        i := 0
        while i < node.len():
            self._defns.extend(self._preorder(node[i], extra_src_infos))
            i += 2

        return ITree::IModule.new(self._compiler.src_module_name, self._defns, extra_src_infos + [[self._mod_id, null, 0]])



    /////////////////////////////////////////////////////////////////////////////////////////////////
    // Definitions
    //

    //
    // Returns a list of IDefn's
    //

    func _t_defn(self, node, extra_src_infos):

        // defn ::= class_defn
        //      ::= func_defn
        //      ::= import
        //      ::= name ( "," name )* ":=" expr
        //      ::= splice
        //      ::= insert

        ndif node.len() == 1 & node[0].name == "class_defn":
            // defn ::= class_defn
            return [self._preorder(node[0], extra_src_infos)]
        elif node.len() == 1 & node[0].name == "func_defn":
            // defn ::= func_defn
            return [self._preorder(node[0], extra_src_infos)]
        elif node.len() == 1 & node[0].name == "import":
            // defn ::= import
            return self._preorder(node[0], extra_src_infos)
        elif node.len() >= 3:
            // defn ::= name ( "," name )* ":=" expr
            targets := []
            i := 0
            while (name_node := node[i]).name == "name":
                if name_node.len() == 1 & not Tree::Non_Term.instantiated(name_node[0]):
                    // name ::= "ID"
                    targets.append(ITree::IVar.new(name_node[0].value, extra_src_infos + name_node.src_infos))
                elif name_node.len() == 2:
                    // name ::= "&" "ID"
                    raise "XXX"
                else:
                    // name ::= splice
                    //      ::= insert
                    raise "XXX"
                i += 2
            return [ITree::IAssignment.new(ITree::STD_ASSIGN, targets, self._preorder(node[-1], extra_src_infos), extra_src_infos + node.src_infos)]
        elif node[0].name == "splice":
            // defn ::= splice
            splice_node := node[0]
            defn := self._eval_splice(splice_node, extra_src_infos)
            if Builtins::List.instantiated(defn):
                for d := defn.iter():
                    ITree_WF::wf_expr(d, "splice result", extra_src_infos + splice_node.src_infos)
                return defn
            elif ITree::IPass.instantiated(defn):
                return [defn]
            else:
                // Note that we only execute this clause if the expression returned wasn't a
                // "pass" statement; if it was, we let it sail on harmlessly by.

                ITree_WF::wf_expr(defn, "splice result", extra_src_infos + splice_node.src_infos)

                return [defn]
        elif node[0].name == "insert":
            return self._preorder(node[0], extra_src_infos)



    //
    // Returns a list of assignment's of imports.
    //

    func _t_import(self, node, extra_src_infos):

        // import ::= "IMPORT" import_name import_as ( "," import_name import_as )*

        imports := []
        i := 1
        while i < node.len():
            // import_name ::= "ID" ( "::" "ID" )*
            name_node := node[i]
            
            mod_path_list := [name_node[0].value]
            j := 1
            while j < name_node.len() & name_node[j].type == "::":
                mod_path_list.append(name_node[j + 1].value)
                j += 2

            if node[i + 1].len() == 2:
                // import_as ::= "AS" "ID"
                import_as := node[i + 1][1].value
            else:
                // import_as ::=
                import_as := name_node[-1].value

            import_ := ITree::IImport.new(Strings::join(mod_path_list, "::"), import_as, extra_src_infos + node.src_infos)
            
            imports.append(import_)
            i += 3

        return imports



    //
    // Returns an IClass_Defn.
    //

    func _t_class_defn(self, node, extra_src_infos):

        // class_defn ::= "CLASS" class_name class_supers class_metaclass ":" "INDENT" class_fields "DEDENT"
        
        name_node := node[1]
        if name_node.len() == 0:
            // class_name ::=
            class_name := null
        else:
            // class_name ::= name
            class_name := self._preorder(name_node[0], extra_src_infos)
        
        supers := []
        i := 1
        while i < node[2].len():
            // class_supers ::= "(" expr ( "," expr )* ")"
            supers.append(self._preorder(node[2][i], extra_src_infos))
            i += 2
        
        if node[3].len() > 0:
            // class_metaclass ::= "METACLASS" expr	
            metaclass_ := self._preorder(node[3][1], extra_src_infos)
        else:
            // class_metaclass ::=
            metaclass_ := null
        
        self._nesting.append(_NEST_CLASS)
        fields := []
        i := 0
        while i < node[6].len():
            // class_fields ::= class_field { "NEWLINE" class_field }*
            field_node := node[6][i]
            ndif field_node.len() == 1 & not Tree::Non_Term.instantiated(field_node[0]):
                // class_field ::= "PASS"
                fields.append(ITree::IPass.new(field_node.src_infos))
            elif field_node.len() == 1 & field_node[0].name == "class_defn":
                // class_field ::= class_defn
                class_defn := field_node[0]
                if class_defn[1].len() == 0:
                    // class_name ::=
                    self._compiler.error("Classes as class fields can not be anonymous.", class_defn.src_infos)
                fields.append(self._preorder(class_defn, extra_src_infos))
            elif field_node.len() == 1 & field_node[0].name == "func_defn":
                // class_field ::= func_def
                func_defn := field_node[0]
                if func_defn[1].len() == 0:
                    // func_name ::=
                    self._compiler.error("Functions as class fields can not be anonymous.", func_defn.src_infos)
                fields.append(self._preorder(func_defn, extra_src_infos))
            elif field_node.len() == 3 & field_node[0].name == "name":
                // class_field ::= name ":=" expr
                fields.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [self._preorder(field_node[0], extra_src_infos)], self._preorder(field_node[2], extra_src_infos), extra_src_infos + field_node.src_infos))
            elif field_node.len() == 1 & field_node[0].name == "splice":
                // class_field ::= splice
                sp := self._eval_splice(field_node[0], extra_src_infos)
                if Builtins::List.instantiated(sp):
                    fields.extend(sp)
                else:
                    fields.append(sp)
            elif field_node.len() == 1 & field_node[0].name == "insert":
                // class_field ::= insert
                fields.append(self._preorder(field_node[0]))
            i += 2
        self._nesting.pop()

        return ITree::IClass_Defn.new(class_name, supers, metaclass_, fields, extra_src_infos + node.src_infos)



    //
    // Returns an IFunc_Defn.
    //

    func _t_func_defn(self, node, extra_src_infos):

        // func_defn ::= func_type func_name "(" func_params ")" ":" "INDENT" func_decls expr_seq
        //              "DEDENT"
        //           ::= func_type func_name "(" func_params ")" "{" "INDENT" func_decls expr_seq
        //               "DEDENT" "NEWLINE" "}"
        //           ::= func_type func_name "(" func_params ")" "{" expr "}"

        type_node := node[0][0]
        if type_node.type == "FUNC":
            // func_type ::= "FUNC"
            if self._nesting.len() == 0 | self._nesting[-1] != _NEST_CLASS:
                is_bound := 0
            else:
                is_bound := 1
        elif type_node.type == "BOUND_FUNC":
            // func_type ::= "BOUND_FUNC"
            is_bound := 1
        elif type_node.type == "UNBOUND_FUNC":
            // func_type ::= "UNBOUND_FUNC"
            is_bound := 0

        name_node := node[1]
        if name_node.len() == 0:
            // func_name ::=
            func_name := null
        elif Tree::Non_Term.instantiated(name_node[0]):
            // func_name ::= name
            func_name := self._preorder(name_node[0], extra_src_infos)
        else:
            //           ::= "+"
            //           ::= "-"
            //           ::= "/"
            //           ::= "*"
            //           ::= "<"
            //           ::= ">"
            //           ::= "=="
            //           ::= "!="
            //           ::= ">="
            //           ::= "<="
            func_name := ITree::IVar.new(name_node[0].type, name_node.src_infos)

        self._nesting.append(_NEST_FUNC)
        params := []
        params_node := node[3]
        if params_node.len() > 0:
            // func_params ::= func_params_elems "," func_varargs
            //             ::= func_params_elems
            //             ::= func_varargs
            var_args := null
            if params_node[0].name == "func_params_elems":
                // func_params_elems  ::= name func_param_default { "," name func_param_default }*
                //                    ::= splice
                //                    ::= insert
                elems_node := params_node[0]
                if elems_node.len() == 1:
                    // func_params_elems ::= splice
                    //                   ::= insert
                    raise "XXX"
                else:
                    // func_params_elems  ::= name func_param_default { "," name func_param_default }*
                    i := 0
                    while i < elems_node.len():
                        if elems_node[i + 1].len() > 1:
                            // func_param_default ::= ":=" expr
                            param_default := self._preorder(elems_node[i + 1][1], extra_src_infos)
                        else:
                            param_default := null
                        var_def := elems_node[i]
                        if elems_node[i].len() == 1 & not Tree::Non_Term.instantiated(elems_node[i][0]):
                            // name ::= "ID"
                            params.append(ITree::IParam.new(ITree::IVar.new(elems_node[i][0].value, extra_src_infos + elems_node[i].src_infos), param_default, extra_src_infos + elems_node[i].src_infos))
                        elif elems_node[i].len() == 1:
                            // name ::= splice
                            //      ::= insert
                            if elems_node[i][0].name == "splice":
                                raise "XXX"
                            else:
                                params.append(self._preorder(elems_node[i]))
                        else:
                            // name ::= "&" "ID"
                            
                            if self._meta_level == 0:
                                self._compiler.error("Dynamically scoped variables only allowed " \
                                  + "directly inside quasi-quotes.", elems_node[i].src_infos)
                            
                            src_infos := extra_src_infos + var_def.src_infos
                            
                            itree_mod_imp := ITree::IMod_Id_Import.new(ITree.mod_id, ITree.src_path, src_infos)

                            ivar := ITree::IModule_Lookup.new([itree_mod_imp, ITree::IVar.new("IVar", src_infos)], src_infos)
                            ivar_new := ITree::ISlot_Lookup.new(ivar, "new", src_infos)
                            var := ITree::IApplication.new(ivar_new, [ITree::IString.new(var_def[1].value, src_infos), Lift::lift(src_infos)], src_infos)

                            iparam := ITree::IModule_Lookup.new([itree_mod_imp, ITree::IVar.new("IParam", src_infos)], src_infos)
                            iparam_new := ITree::ISlot_Lookup.new(iparam, "new", src_infos)
                            if param_default is null:
                                inull := ITree::IVar.new("null", src_infos)
                                param := ITree::IApplication.new(iparam_new, [var, inull, Lift::lift(src_infos)], src_infos)
                            else:
                                param := ITree::IApplication.new(iparam_new, [var, param_default, Lift::lift(src_infos)], src_infos)
                            
                            params.append(ITree::IInsert.new(ITree::INSERT_CAPTURING, param, src_infos))
                        i += 3
            if params_node[-1].name == "func_varargs":
                // func_varargs ::= "*" name
                //              ::= "*" splice
                //              ::= "*" insert
                varargs_node := params_node[-1]
                if varargs_node[1].name == "name":
                    // func_varargs ::= "*" name
                    var_args := ITree::IVar.new(varargs_node[1][0].value, extra_src_infos + varargs_node.src_infos)
                elif varargs_node[1].name == "splice":
                    // func_varargs ::= "*" splice
                    raise "XXX"
                else:	
                    // func_varargs ::= "*" insert
                    var_args := self._preorder(varargs_node[0])
        else:
            // func_params ::=
            var_args := null

        nonlocals := []
        renames := []

        if node.len() == 8:
            body := ITree::IExpr_Seq.new([self._preorder(node[6])], extra_src_infos + node[5].src_infos)
        else:
            i := 0
            decls_node := node[7]
            while i < decls_node.len():
                // func_decls ::= func_decl { "NEWLINE" func_decl }*
                // func_decl  ::= func_decl_nonlocals
                //            ::= func_decl_rename

                decl := decls_node[i][0]
                if decl.name == "func_decl_nonlocals":
                    // func_decl_nonlocals ::= "NONLOCAL" name ( "," name )* "NEWLINE"
                    j := 1
                    while j < decl.len():
                        var := self._preorder(decl[j], extra_src_infos)
                        nonlocals.append(var)
                        j += 2
                else:
                    // func_decl_rename ::= "RENAME" func_decl_rename_elem ( ","
                    //                      func_decl_rename_elem )* "NEWLINE"
                    j := 0
                    while j < decl.len():
                        rename_ := decl[j + 1]
                        if rename_.len() == 3:
                            // func_decl_rename_elem ::= name "AS" name
                            rename_from := self._preorder(rename_[0], extra_src_infos)
                            rename_as := self._preorder(rename_[2], extra_src_infos)
                            renames.append(ITree::IRename.new(rename_from, rename_as, decl[j].src_infos))
                        elif rename_[0].name == "splice":
                            // func_decl_rename_elem ::= splice
                            splice := rename_[0]
                            rename_ := self._eval_splice(splice, extra_src_infos)
                            if not (ITree::IRename.instantiated(rename_) & ITree_WF::wf(rename_)):
                                ITree_WF::type_error("IRename", "splice result", extra_src_infos + splice.src_infos)
                            renames.append(rename_)
                        else:
                            // func_decl_rename_elem ::= insert
                            renames.append(self._preorder(rename_[0]))
                        j += 3

                i += 2
        
            body := self._preorder(node[8], extra_src_infos)

        self._nesting.pop()
        
        return ITree::IFunc_Defn.new(is_bound, func_name, params, var_args, nonlocals, renames, body, extra_src_infos + node.src_infos)




    /////////////////////////////////////////////////////////////////////////////////////////////////
    // Expressions
    //
    // These functions should all return an instance of IExpr.
    //

    func _t_expr(self, node, extra_src_infos):

        // expr ::= class_def
        //      ::= func_def
        //      ::= while
        //      ::= if
        //      ::= for
        //      ::= try
        //      ::= number
        //      ::= var_lookup
        //      ::= dict
        //      ::= set
        //      ::= list
        //      ::= dict
        //      ::= string
        //      ::= slot_lookup
        //      ::= module_lookup
        //      ::= list
        //      ::= application
        //      ::= get
        //      ::= slice
        //      ::= exbi
        //      ::= return
        //      ::= yield
        //      ::= fail
        //      ::= raise
        //      ::= assert
        //      ::= break
        //      ::= continue
        //      ::= conjunction
        //      ::= alternation
        //      ::= assignment
        //      ::= not
        //      ::= neg
        //      ::= binary
        //      ::= comparison
        //      ::= pass
        //      ::= import
        //      ::= splice
        //      ::= insert
        //      ::= quasi_quotes
        //      ::= brackets

        expr_node := node[0]
        if expr_node.name == "import":
            imports := self._preorder(expr_node, extra_src_infos)
            if imports.len() == 0:
                return imports[0]
            else:
                return ITree::IConjunction.new(imports, extra_src_infos + node.src_infos)
        else:
            return self._preorder(expr_node, extra_src_infos)



    func _t_if(self, node, extra_src_infos):
    
        // if ::= "IF" expr ":" "INDENT" expr_seq "DEDENT" ( if_elif )* if_else
        //    ::= "IF" expr "{" "INDENT" expr_seq "DEDENT" "NEWLINE" "}" ( if_elif )* if_else
        
        clauses := [ITree::IClause.new(self._preorder(node[1], extra_src_infos), self._preorder(node[4]), extra_src_infos + node[1].src_infos)]
        if Tree::Non_Term.instantiated(node[6]):
            // if ::= "IF" expr ":" "INDENT" expr_seq "DEDENT" ( if_elif )* if_else
            i := 6
        else:
            // if ::= "IF" expr "{" "INDENT" expr_seq "DEDENT" "NEWLINE" "}" ( if_elif )* if_else
            i := 8
        while (elif_node := node[i]).name == "if_elif":
            // if_elif ::= "NEWLINE" "ELIF" expr ":" "INDENT" expr_seq "DEDENT"
            //         ::= "NEWLINE" "ELIF" expr "{" "INDENT" expr_seq "DEDENT" "NEWLINE" "}"
            clauses.append(ITree::IClause.new(self._preorder(elif_node[2], extra_src_infos), self._preorder(elif_node[5]), extra_src_infos + elif_node[2].src_infos))
            i += 1
        
        if node[-1].len() > 1:
            // if_else ::= "NEWLINE" "ELSE" ":" "INDENT" expr_seq "DEDENT"
            //         ::= "NEWLINE" "ELSE" "{" "INDENT" expr_seq "DEDENT" "NEWLINE" "}"
            else_body := self._preorder(node[-1][4])
        else:
            // if_else ::=
            else_body := null

        return ITree::IIf.new(clauses, else_body, extra_src_infos + node.src_infos)



    func _t_ndif(self, node, extra_src_infos):
    
        // ndif ::= "NDIF" expr ":" "INDENT" expr_seq "DEDENT" ( if_elif )*
        //      ::= "NDIF" expr "{" "INDENT" expr_seq "DEDENT" "NEWLINE" "}" ( if_elif )*
        
        clauses := [ITree::IClause.new(self._preorder(node[1], extra_src_infos), self._preorder(node[4]), extra_src_infos + node[1].src_infos)]
        if node.len() == 6 | Tree::Non_Term.instantiated(node[6]):
            // ndif ::= "NDIF" expr ":" "INDENT" expr_seq "DEDENT" ( if_elif )*
            i := 6
        else:
            // ndif ::= "NDIF" expr "{" "INDENT" expr_seq "DEDENT" "NEWLINE" "}" ( if_elif )*
            i := 8
        while i < node.len() & (elif_node := node[i]).name == "if_elif":
            // if_elif ::= "NEWLINE" "ELIF" expr ":" "INDENT" expr_seq "DEDENT"
            //         ::= "NEWLINE" "ELIF" expr "{" "INDENT" expr_seq "DEDENT" "NEWLINE" "}"
            clauses.append(ITree::IClause.new(self._preorder(elif_node[2], extra_src_infos), self._preorder(elif_node[5]), extra_src_infos + elif_node.src_infos))
            i += 1

        return ITree::INDIf.new(clauses, extra_src_infos + node.src_infos)



    func _t_while(self, node, extra_src_infos):
    
        // while ::= "WHILE" expr ":" "INDENT" expr_seq "DEDENT" exhausted broken
        //       ::= "WHILE" expr
        
        if node.len() == 8:
            // while ::= "WHILE" expr ":" "INDENT" expr_seq "DEDENT" exhausted broken
            expr_seq := self._preorder(node[4])
            if node[6].len() > 0:
                exhausted_body := self._preorder(node[6][4])
            else:
                exhausted_body := null

            if node[7].len() > 0:
                broken_body := self._preorder(node[7][4])
            else:
                broken_body := null
        else:
            // while ::= "WHILE" expr
            expr_seq := exhausted_body := broken_body := null
        
        return ITree::IWhile.new(self._preorder(node[1], extra_src_infos), expr_seq, exhausted_body, broken_body, extra_src_infos + node.src_infos)



    func _t_for(self, node, extra_src_infos):
    
        // for ::= "FOR" expr ":" "INDENT" expr_seq "DEDENT" exhausted broken
        //     ::= "FOR" expr

        if node.len() == 8:
            // while ::= "FOR" expr ":" "INDENT" expr_seq "DEDENT" exhausted broken
            body := self._preorder(node[4])
            if node[6].len() > 0:
                exhausted_body := self._preorder(node[6][4])
            else:
                exhausted_body := null
            if node[7].len() > 0:
                broken_body := self._preorder(node[7][4])
            else:
                broken_body := null
        else:
            // for ::= "FOR" expr
            body := null
            exhausted_body := null
            broken_body := null
        
        return ITree::IFor.new(self._preorder(node[1], extra_src_infos), body, exhausted_body, broken_body, extra_src_infos + node.src_infos)



    func _t_try(self, node, extra_src_infos):

        // try ::= "TRY" ":" "INDENT" expr_seq "DEDENT" ( try_catch )*
        
        body := self._preorder(node[3])

        catches := []
        i := 5
        while i < node.len():
            // try_catch ::= "NEWLINE" "CATCH" expr try_catch_var ":" "INDENT" expr_seq "DEDENT"
            catch_node := node[i]
            catch_expr := self._preorder(catch_node[2])
            if catch_node[3].len() > 0:
                // try_catch_var ::= "INTO" name
                catch_var := self._preorder(catch_node[3][1])
            else:
                catch_var := null
            catch_body := self._preorder(catch_node[6])
            catches.append(ITree::ICatch.new(catch_expr, catch_var, catch_body, catch_node.src_infos))
            i += 1
        
        return ITree::ITry.new(body, catches, extra_src_infos + node.src_infos)



    func _t_number(self, node, extra_src_infos):
    
        // number ::= "INT"
        //        ::= "FLOAT"
    
        num_node := node[0]
        if num_node.type == "INT":
            return ITree::IInt.new(Builtins::Int.new(num_node.value), extra_src_infos + node.src_infos)
        elif num_node.type == "FLOAT":
            return ITree::IFloat.new(Builtins::Float.new(num_node.value), extra_src_infos + node.src_infos)


    func _t_name(self, node, extra_src_infos):
    
        // name ::= "ID"
        //      ::= "&" "ID"
        //      ::= splice
        //      ::= insert
        
        if node.len() == 1 & not Tree::Non_Term.instantiated(node[0]):
            // name ::= "ID"
            if node[0].value == SRC_INFO_VAR:
                raise "XXX"
            else:
                return ITree::IVar.new(node[0].value, extra_src_infos + node.src_infos)
        elif node.len() == 2:
            // name ::= "&" "ID"
            src_infos := extra_src_infos + node.src_infos
            if self._meta_level == 0:
                self._compiler.error("Dynamically scoped variables only allowed " \
                  + "directly inside quasi-quotes.", src_infos)

            itree_mod_imp := ITree::IMod_Id_Import.new(ITree.mod_id, ITree.src_path, src_infos)
            ivar := ITree::IModule_Lookup.new([itree_mod_imp, ITree::IVar.new("IVar", src_infos)], src_infos)
            ivar_new := ITree::ISlot_Lookup.new(ivar, "new", src_infos)
            var := ITree::IApplication.new(ivar_new, [ITree::IString.new(node[1].value, src_infos), Lift::lift(src_infos)], src_infos)
            return ITree::IInsert.new(ITree::INSERT_CAPTURING, var, src_infos)
        elif node[0].name == "splice":
            // name ::= splice
            splice_node := node[0]
            name := self._eval_splice(splice_node, splice_node.src_infos)
            if (ITree::IVar.instantiated(name) | ITree::IGet.instantiated(name) \
              | ITree::ISlot_Lookup.instantiated(name)) & ITree_WF::wf(name):
                return name
            msg := Strings::format("Splice returned '%s' instead of '[IVar, IGet, ISlot_Lookup]'.", \
              name.instance_of.name)
            self._compiler.error(msg, node.src_infos)
            return name
        else:
            // name ::= insert
            return self._preorder(node[0])



    func _t_var_lookup(self, node, extra_src_infos):
    
        // var_lookup ::= "ID"
        //            ::= "&" "ID"
        
        if node.len() == 1 & not Tree::Non_Term.instantiated(node[0]):
            // name ::= "ID"
            name_node := node[0]
            if name_node.value == SRC_INFO_VAR:
                assert name_node.src_infos.len() == 1
                src_path := ITree::IString.new(name_node.src_infos[0][0], extra_src_infos + name_node.src_infos)
                src_offset := ITree::IInt.new(name_node.src_infos[0][1], extra_src_infos + name_node.src_infos)
                src_len := ITree::IInt.new(name_node.src_infos[0][2], extra_src_infos + name_node.src_infos)
                return ITree::IList.new([ITree::IList.new([src_path, src_offset, src_len], extra_src_infos + name_node.src_infos)], extra_src_infos + name_node.src_infos)
            else:
                return ITree::IVar.new(name_node.value, extra_src_infos + name_node.src_infos)
        elif node.len() == 2:
            // name ::= "&" "ID"
            src_infos := extra_src_infos + node.src_infos

            if self._meta_level == 0:
                self._compiler.error("Dynamically scoped variables only allowed " \
                  + "directly inside quasi-quotes.", src_infos)

            itree_mod_imp := ITree::IMod_Id_Import.new(ITree.mod_id, ITree.src_path, src_infos)
            ivar := ITree::IModule_Lookup.new([itree_mod_imp, ITree::IVar.new("IVar", src_infos)], src_infos)
            ivar_new := ITree::ISlot_Lookup.new(ivar, "new", src_infos)
            var := ITree::IApplication.new(ivar_new, [ITree::IString.new(node[1].value, src_infos), Lift::lift(src_infos)], node.src_infos)
            
            return ITree::IInsert.new(ITree::INSERT_CAPTURING, var, node.src_infos)



    func _t_string(self, node, extra_src_infos):
    
        // string ::= "STRING"
        
        return ITree::IString.new(node[0].value, extra_src_infos + node.src_infos)



    func _t_slot_lookup(self, node, extra_src_infos):
    
        // slot_lookup ::= expr "." "ID"
        //             ::= expr "." splice
        //             ::= expr "." insert
        
        if Tree::Non_Term.instantiated(node[2]):
            // slot_lookup ::= expr "." splice
            //             ::= expr "." insert
            if node[2].name == "splice":
                raise "XXX"
            else:
                return ITree::ISlot_Lookup.new(self._preorder(node[0], extra_src_infos), self._preorder(node[2]), extra_src_infos + node.src_infos)
        else:
            // slot_lookup ::= expr "." "ID"
            return ITree::ISlot_Lookup.new(self._preorder(node[0], extra_src_infos), node[2].value, extra_src_infos + node.src_infos)
        
        
        
    func _t_module_lookup(self, node, extra_src_infos):
    
        // module_lookup ::= name ( "::" name )+
        
        names := []
        i := 0
        while i < node.len():
            names.append(self._preorder(node[i], extra_src_infos))
            i += 2

        return ITree::IModule_Lookup.new(names, extra_src_infos + node.src_infos)



    func _t_list(self, node, extra_src_infos):
    
        // list ::= "[" expr { "," expr }* "]"
        //      ::= "[" "]"
        
        elems := []
        i := 1
        while i < node.len() & Tree::Non_Term.instantiated(node[i]):
            elems.append(self._preorder(node[i], extra_src_infos))
            i += 2
        
        return ITree::IList.new(elems, extra_src_infos + node.src_infos)



    func _t_dict(self, node, extra_src_infos):
    
        // dict ::= "DICT{" expr ":" expr ( "," expr ":" expr )* "CLOSE_CURLY"
        //      ::= "DICT{" "CLOSE_CURLY"
        
        elems := []
        i := 1
        while i < node.len() & Tree::Non_Term.instantiated(node[i]):
            key := self._preorder(node[i], extra_src_infos)
            val := self._preorder(node[i + 2], extra_src_infos)
            elem := ITree::IDict_Elem.new(key, val, node[i + 1].src_infos)
            elems.append(elem)
            i += 4
        
        return ITree::IDict.new(elems, extra_src_infos + node.src_infos)



    func _t_set(self, node, extra_src_infos):
    
        // set ::= "SET{" expr ( "," expr )* "CLOSE_CURLY"
        //     ::= "SET{" "CLOSE_CURLY"
        
        elems := []
        i := 1
        while i < node.len() & Tree::Non_Term.instantiated(node[i]):
            elems.append(self._preorder(node[i], extra_src_infos))
            i += 2
        
        return ITree::ISet.new(elems, extra_src_infos + node.src_infos)



    func _t_application(self, node, extra_src_infos):

        // application ::= expr "(" expr ( "," expr )* ")"
        //             ::= expr "(" ")"
        
        params := []
        i := 2
        while i < node.len() & Tree::Non_Term.instantiated(node[i]):
            params.append(self._preorder(node[i], extra_src_infos))
            i += 2

        return ITree::IApplication.new(self._preorder(node[0], extra_src_infos), params, extra_src_infos + node.src_infos)



    func _t_get(self, node, extra_src_infos):
    
        // get ::= expr "[" expr "]"
        
        return ITree::IGet.new(self._preorder(node[0], extra_src_infos), self._preorder(node[2], extra_src_infos), extra_src_infos + node.src_infos)



    func _t_slice(self, node, extra_src_infos):
    
        // slice ::= expr "[" expr ":" expr "]"
        //       ::= expr "[" ":" expr "]"
        //       ::= expr "[" expr ":" "]"
        //       ::= expr "[" ":" "]"
        
        if node.len() == 6:
            // slice ::= expr "[" expr ":" expr "]"
            lower_bound := self._preorder(node[2], extra_src_infos)
            upper_bound := self._preorder(node[4], extra_src_infos)
        elif node.len() == 5 & not Tree::Non_Term.instantiated(node[2]):
            // slice ::= expr "[" ":" expr "]"
            lower_bound := null
            upper_bound := self._preorder(node[3], extra_src_infos)
        elif node.len() == 5:
            // slice ::= expr "[" expr ":" "]"
            lower_bound := self._preorder(node[2], extra_src_infos)
            upper_bound := null
        else:
            lower_bound := null
            upper_bound := null
        
        return ITree::ISlice.new(self._preorder(node[0], extra_src_infos), lower_bound, upper_bound, extra_src_infos + node.src_infos)



    func _t_exbi(self, node, extra_src_infos):

        // exbi ::= "EXBI" expr "." "ID"

        return ITree::IEXBI.new(self._preorder(node[1], extra_src_infos), node[3].value, extra_src_infos + node.src_infos)


    
    func _t_return(self, node, extra_src_infos):
    
        // return ::= "RETURN" expr
        //        ::= "RETURN"
        
        if node.len() == 2:
            expr := self._preorder(node[1], extra_src_infos)
        else:
            expr := null
        
        return ITree::IReturn.new(expr, extra_src_infos + node.src_infos)



    func _t_yield(self, node, extra_src_infos):
    
        // yield ::= "YIELD" expr
        
        return ITree::IYield.new(self._preorder(node[1], extra_src_infos), extra_src_infos + node.src_infos)



    func _t_fail(self, node, extra_src_infos):
    
        // fail ::= "FAIL"
        
        return ITree::IFail.new(extra_src_infos + node.src_infos)



    func _t_raise(self, node, extra_src_infos):
    
        // raise ::= "RAISE" expr
        
        return ITree::IRaise.new(self._preorder(node[1], extra_src_infos), extra_src_infos + node.src_infos)



    func _t_assert(self, node, extra_src_infos):
    
        // assert ::= "ASSERT" expr
        
        return ITree::IAssert.new(self._preorder(node[1], extra_src_infos), extra_src_infos + node.src_infos)



    func _t_break(self, node, extra_src_infos):
    
        // break ::= "BREAK"
        
        return ITree::IBreak.new(extra_src_infos + node.src_infos)



    func _t_continue(self, node, extra_src_infos):
    
        // continue ::= "CONTINUE"
        
        return ITree::IContinue.new(extra_src_infos + node.src_infos)



    func _t_conjunction(self, node, extra_src_infos):
    
        // conjunction ::= expr ( "&" expr )+
        
        exprs := []
        i := 0
        while i < node.len():
            exprs.append(self._preorder(node[i], extra_src_infos))
            i += 2
        
        return ITree::IConjunction.new(exprs, extra_src_infos + node.src_infos)



    func _t_alternation(self, node, extra_src_infos):
    
        // alternation ::= expr ( "|" expr )+
        
        exprs := []
        i := 0
        while i < node.len():
            exprs.append(self._preorder(node[i], extra_src_infos))
            i += 2
        
        return ITree::IAlternation.new(exprs, extra_src_infos + node.src_infos)



    func _t_assignment(self, node, extra_src_infos):

        // assignment ::= assignment_target ( "," assignment_target )* assignment_type expr
        
        targets := []
        i := 0
        while (tgt_node := node[i]).name == "assignment_target":
            // assignment_target ::= name
            //                   ::= slot_lookup
            //                   ::= lookup
            //                   ::= slice
            
            if tgt_node[0].name == "name":
                targets.append(self._preorder(tgt_node[0], extra_src_infos))
            else:
                targets.append(self._preorder(tgt_node[0], extra_src_infos))
            i += 2
            
        expr := self._preorder(node[-1], extra_src_infos)
        
        if node[-2][0].type == ":=":
            // assignment_type ::= ":="
            type := ITree::STD_ASSIGN
        elif node[-2][0].type == "*=":
            //                 ::= "*="
            type := ITree::MUL_ASSIGN
        elif node[-2][0].type == "/=":
            //                 ::= "/="
            type := ITree::DIV_ASSIGN
        elif node[-2][0].type == "+=":
            //                 ::= "+="
            type := ITree::ADD_ASSIGN
        else:
            //                 ::= "-="
            type := ITree::SUB_ASSIGN
        
        return ITree::IAssignment.new(type, targets, expr, extra_src_infos + node.src_infos)



    func _t_neg(self, node, extra_src_infos):
    
        // neg ::= "-" expr
        
        return ITree::IBinary.new(ITree::BINARY_SUB, ITree::IInt.new(0, extra_src_infos + node.src_infos), self._preorder(node[1], extra_src_infos), extra_src_infos + node.src_infos)



    func _t_not(self, node, extra_src_infos):
    
        // not ::= "NOT" expr
        
        return ITree::INot.new(self._preorder(node[1], extra_src_infos), extra_src_infos + node.src_infos)



    func _t_binary(self, node, extra_src_infos):
    
        // binary    ::= expr "*" expr
        //             | expr "/" expr
        //             | expr "%" expr
        //             | expr "+" expr
        //             | expr "-" expr


        op_node := node[1]
        ndif op_node.type == "*":
            type := ITree::BINARY_MUL
        elif op_node.type == "/":
            type := ITree::BINARY_DIV
        elif op_node.type == "%":
            type := ITree::BINARY_MOD
        elif op_node.type == "+":
            type := ITree::BINARY_ADD
        elif op_node.type == "-":
            type := ITree::BINARY_SUB
        
        return ITree::IBinary.new(type, self._preorder(node[0], extra_src_infos), self._preorder(node[2], extra_src_infos), extra_src_infos + node.src_infos)



    func _t_comparison(self, node, extra_src_infos):
    
        // comparison ::= expr comparison_op expr
        
        op_node := node[1][0]
        if op_node.type == "IS":
            // comparison_op ::= "IS"
            type := ITree::IS_COMPARISON
        elif op_node.type == "==":
            // comparison_op ::= ==
            type := ITree::EQ_COMPARISON
        elif op_node.type == "!=":
            // comparison_op ::= !=
            type := ITree::NEQ_COMPARISON
        elif op_node.type == "<=":
            // comparison_op ::= <=
            type := ITree::LEQ_COMPARISON
        elif op_node.type == ">=":
            // comparison_op ::= >=
            type := ITree::GEQ_COMPARISON
        elif op_node.type == "<":
            // comparison_op ::= <
            type := ITree::LE_COMPARISON
        elif op_node.type == ">":
            // comparison_op ::= >
            type := ITree::GE_COMPARISON

        return ITree::IComparison.new(type, self._preorder(node[0], extra_src_infos), self._preorder(node[2], extra_src_infos), extra_src_infos + node.src_infos)



    func _t_pass(self, node, extra_src_infos):
    
        // pass ::= "PASS"
    
        return ITree::IPass.new(extra_src_infos + node.src_infos)



    func _t_brackets(self, node, extra_src_infos):
    
        // brackets ::= "(" expr ")"
        
        return self._preorder(node[1], extra_src_infos)



    //
    // This traversal node is a little different than it may first appear. It is not intended to
    // proecss *every* splice node; it is only intended to process splices which are used as
    // bog-standard expressions.
    //
    // When splices are used in other places (e.g. in expression bodies (where they can return
    // a single IExpr or a list of IExpr's) or in function parameters etc.) the splice should be
    // handled separately.
    //

    func _t_splice(self, node, extra_src_infos):

        // splice ::= expr_splice
        //        ::= dsl_splice

        result := self._eval_splice(node, extra_src_infos)
        ITree_WF::wf_expr(result, "splice", extra_src_infos + node.src_infos)
        
        return result



    func _t_insert(self, node, extra_src_infos):
    
        // insert ::= "$" insert_type "{" expr "}"

        if self._meta_level == 0:
            self._compiler.error("Insertions only allowed directly inside quasi-quotes.", \
              node.src_infos)

        it_node := node[1]
        if it_node.len() == 1:
            // insert_type ::= "ID"
            type_itr := it_node[0].value
            if type_itr == "c":
                it := ITree::INSERT_CAPTURING
            else:
                msg := Strings::format("Unknown insert type '%s'.", type_itr)
                self._compiler.error(msg, it_node.src_infos)
        else:
            it := ITree::INSERT_DEFAULT

        self._meta_level -= 1
        expr := self._preorder(node[3], extra_src_infos)
        self._meta_level += 1

        return ITree::IInsert.new(it, expr, extra_src_infos + node.src_infos)



    func _t_quasi_quotes(self, node, extra_src_infos):

        // quasi_quotes ::= quasi_quotes_customize "INDENT" expr_seq "DEDENT" "NEWLINE" "|]"
        //              ::= quasi_quotes_customize expr "|]"

        self._meta_level += 1
        
        if node.len() == 6:
            // expr_quasi_quotes ::= quasi_quotes_customize "INDENT" expr_seq "DEDENT" "NEWLINE"
            //                       "|]"
            body := self._preorder(node[2], extra_src_infos)
        else:
            // expr_quasi_quotes ::= quasi_quotes_customize expr "|]"
            expr := self._preorder(node[1])
            body := ITree::IExpr_Seq.new([expr], extra_src_infos + expr.src_infos)

        if node[0].len() == 1:
            // quasi_quotes_customize ::= "[|"
            qq_extra_src_infos := null
        else:
            // quasi_quotes_customize ::= "[" "<" expr ">" "|"
            qq_extra_src_infos := self._preorder(node[0][2], extra_src_infos)

        self._meta_level -= 1

        sqq := ITree::IQuasi_Quotes.new(body, qq_extra_src_infos, extra_src_infos + node.src_infos)

        ITree_WF::wf(sqq)

        return sqq



    ////////////////////////////////////////////////////////////////////////////////////////////////
    // "Virtual" elements
    //
        
    func _t_expr_seq(self, node, extra_src_infos := []):

        // expr_seq ::= expr ( "NEWLINE" expr )*

        exprs := []
        i := 0
        while i < node.len():
            expr_node := node[i]
            if expr_node[0].name == "splice":
                splice_node := expr_node[0]
                expr := self._eval_splice(splice_node, extra_src_infos)
                if Builtins::List.instantiated(expr):
                    for e := expr.iter():
                        ITree_WF::wf_expr(e, "splice result", extra_src_infos + splice_node.src_infos)
                    exprs.extend(expr)
                elif not ITree::IPass.instantiated(expr):
                    // Note that we only execute this clause if the expression returned wasn't a
                    // "pass" statement; if it was, we let it sail on harmlessly by.

                    ITree_WF::wf_expr(expr, "splice result", extra_src_infos + splice_node.src_infos)
                    exprs.append(expr)
            elif expr_node[0].name == "import":
                exprs.extend(self._t_import(expr_node[0], extra_src_infos))
            else:
                exprs.append(self._preorder(expr_node, extra_src_infos))
            i += 2

        if exprs.len() == 0:
            return ITree::IExpr_Seq.new(exprs, extra_src_infos)
        else:
            return ITree::IExpr_Seq.new(exprs, extra_src_infos + exprs[0].src_infos)
